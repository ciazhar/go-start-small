// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: payment.sql

package db

import (
	"context"
	"database/sql"

	"github.com/jackc/pgtype"
)

const createPayment = `-- name: CreatePayment :exec
INSERT INTO payment (order_id, payment_method_id, amount)
VALUES ($1::int, $2::int, $3::float)
`

type CreatePaymentParams struct {
	OrderID         int32   `json:"order_id"`
	PaymentMethodID int32   `json:"payment_method_id"`
	Amount          float64 `json:"amount"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) error {
	_, err := q.db.Exec(ctx, createPayment, arg.OrderID, arg.PaymentMethodID, arg.Amount)
	return err
}

const getPayments = `-- name: GetPayments :many
SELECT p.payment_id, pm.name AS payment_method, p.amount, p.payment_date
FROM payment p
         INNER JOIN payment_method pm ON p.payment_method_id = pm.payment_method_id
WHERE p.order_id = $1::int
`

type GetPaymentsRow struct {
	PaymentID     int32          `json:"payment_id"`
	PaymentMethod string         `json:"payment_method"`
	Amount        pgtype.Numeric `json:"amount"`
	PaymentDate   sql.NullTime   `json:"payment_date"`
}

func (q *Queries) GetPayments(ctx context.Context, orderID int32) ([]GetPaymentsRow, error) {
	rows, err := q.db.Query(ctx, getPayments, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentsRow{}
	for rows.Next() {
		var i GetPaymentsRow
		if err := rows.Scan(
			&i.PaymentID,
			&i.PaymentMethod,
			&i.Amount,
			&i.PaymentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
